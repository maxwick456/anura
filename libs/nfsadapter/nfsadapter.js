const e=globalThis.showDirectoryPicker;async function t(t={}){if(e&&!t._preferPolyfill)return e(t);const i=document.createElement("input");i.type="file",i.webkitdirectory=!0,i.multiple=!0,i.style.position="fixed",i.style.top="-100000px",i.style.left="-100000px",document.body.appendChild(i);const r=Promise.resolve().then((function(){return p}));return await new Promise((e=>{i.addEventListener("change",e),i.click()})),r.then((e=>e.getDirHandlesFromInput(i)))}const i={accepts:[]},r=globalThis.showOpenFilePicker;async function n(e={}){const t={...i,...e};if(r&&!e._preferPolyfill)return r(t);const n=document.createElement("input");n.type="file",n.multiple=t.multiple,n.accept=(t.accepts||[]).map((e=>[...(e.extensions||[]).map((e=>"."+e)),...e.mimeTypes||[]])).flat().join(","),Object.assign(n.style,{position:"fixed",top:"-100000px",left:"-100000px"}),document.body.appendChild(n);const s=Promise.resolve().then((function(){return p}));return await new Promise((e=>{n.addEventListener("change",e,{once:!0}),n.click()})),n.remove(),s.then((e=>e.getFileHandlesFromInput(n)))}const s=globalThis.showSaveFilePicker;async function a(e={}){if(s&&!e._preferPolyfill)return s(e);e._name&&(console.warn("deprecated _name, spec now have `suggestedName`"),e.suggestedName=e._name);const{FileSystemFileHandle:t}=await Promise.resolve().then((function(){return P})),{FileHandle:i}=await Promise.resolve().then((function(){return R}));return new t(new i(e.suggestedName))}async function o(e,t={}){if(!e)return globalThis.navigator?.storage?.getDirectory()||globalThis.getOriginPrivateDirectory();const{FileSystemDirectoryHandle:i}=await Promise.resolve().then((function(){return F})),r=await e;return new i(await(r.default?r.default(t):r(t)))}globalThis.DataTransferItem&&!DataTransferItem.prototype.getAsFileSystemHandle&&(DataTransferItem.prototype.getAsFileSystemHandle=async function(){const e=this.webkitGetAsEntry(),[{FileHandle:t,FolderHandle:i},{FileSystemDirectoryHandle:r},{FileSystemFileHandle:n}]=await Promise.all([Promise.resolve().then((function(){return L})),Promise.resolve().then((function(){return F})),Promise.resolve().then((function(){return P}))]);return e.isFile?new n(new t(e,!1)):new r(new i(e,!1))});const l={ReadableStream:globalThis.ReadableStream,WritableStream:globalThis.WritableStream,TransformStream:globalThis.TransformStream,DOMException:globalThis.DOMException,Blob:globalThis.Blob,File:globalThis.File},{WritableStream:c}=l;class d extends c{#e;constructor(e){super(e),this.#e=e,Object.setPrototypeOf(this,d.prototype),this._closed=!1}async close(){this._closed=!0;const e=this.getWriter(),t=e.close();return e.releaseLock(),t}seek(e){return this.write({type:"seek",position:e})}truncate(e){return this.write({type:"truncate",size:e})}write(e){if(this._closed)return Promise.reject(new TypeError("Cannot write to a CLOSED writable stream"));const t=this.getWriter(),i=t.write(e);return t.releaseLock(),i}}Object.defineProperty(d.prototype,Symbol.toStringTag,{value:"FileSystemWritableFileStream",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(d.prototype,{close:{enumerable:!0},seek:{enumerable:!0},truncate:{enumerable:!0},write:{enumerable:!0}}),!globalThis.FileSystemFileHandle||globalThis.FileSystemFileHandle.prototype.createWritable||globalThis.FileSystemWritableFileStream||(globalThis.FileSystemWritableFileStream=d);const h=Symbol("adapter");class w{[h];name;kind;constructor(e){this.kind=e.kind,this.name=e.name,this[h]=e}async queryPermission(e={}){const{mode:t="read"}=e,i=this[h];if(i.queryPermission)return i.queryPermission({mode:t});if("read"===t)return"granted";if("readwrite"===t)return i.writable?"granted":"denied";throw new TypeError(`Mode ${t} must be 'read' or 'readwrite'`)}async requestPermission({mode:e="read"}={}){const t=this[h];if(t.requestPermission)return t.requestPermission({mode:e});if("read"===e)return"granted";if("readwrite"===e)return t.writable?"granted":"denied";throw new TypeError(`Mode ${e} must be 'read' or 'readwrite'`)}async remove(e={}){await this[h].remove(e)}async isSameEntry(e){return this===e||!(!e||"object"!=typeof e||this.kind!==e.kind||!e[h])&&this[h].isSameEntry(e[h])}}Object.defineProperty(w.prototype,Symbol.toStringTag,{value:"FileSystemHandle",writable:!1,enumerable:!1,configurable:!0}),globalThis.FileSystemHandle&&(globalThis.FileSystemHandle.prototype.queryPermission??=function(e){return"granted"});const u={INVALID:["seeking position failed.","InvalidStateError"],GONE:["A requested file or directory could not be found at the time an operation was processed.","NotFoundError"],MISMATCH:["The path supplied exists, but was not an entry of requested type.","TypeMismatchError"],MOD_ERR:["The object can not be modified in this way.","InvalidModificationError"],SYNTAX:e=>[`Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. ${e}`,"SyntaxError"],SECURITY:["It was determined that certain files are unsafe for access within a Web application, or that too many calls are being made on file resources.","SecurityError"],DISALLOWED:["The request is not allowed by the user agent or the platform in the current context.","NotAllowedError"]},y={writable:globalThis.WritableStream};var p=Object.freeze({__proto__:null,errors:u,config:y,fromDataTransfer:async function(e){console.warn("deprecated fromDataTransfer - use `dt.items[0].getAsFileSystemHandle()` instead");const[t,i,r]=await Promise.all([Promise.resolve().then((function(){return te})),Promise.resolve().then((function(){return L})),Promise.resolve().then((function(){return F}))]),n=new t.FolderHandle("",!1);return n._entries=e.map((e=>e.isFile?new i.FileHandle(e,!1):new i.FolderHandle(e,!1))),new r.FileSystemDirectoryHandle(n)},getDirHandlesFromInput:async function(e){const{FolderHandle:t,FileHandle:i}=await Promise.resolve().then((function(){return te})),{FileSystemDirectoryHandle:r}=await Promise.resolve().then((function(){return F})),n=Array.from(e.files),s=n[0].webkitRelativePath.split("/",1)[0],a=new t(s,!1);return n.forEach((e=>{const r=e.webkitRelativePath.split("/");r.shift();const n=r.pop();r.reduce(((e,i)=>(e._entries[i]||(e._entries[i]=new t(i,!1)),e._entries[i])),a)._entries[n]=new i(e.name,e,!1)})),new r(a)},getFileHandlesFromInput:async function(e){const{FileHandle:t}=await Promise.resolve().then((function(){return te})),{FileSystemFileHandle:i}=await Promise.resolve().then((function(){return P}));return Array.from(e.files).map((e=>new i(new t(e.name,e,!1))))}});const{GONE:m,MOD_ERR:f}=u,b=Symbol("adapter");class g extends w{[b];constructor(e){super(e),this[b]=e}async getDirectoryHandle(e,t={}){if(""===e)throw new TypeError("Name can't be an empty string.");if("."===e||".."===e||e.includes("/"))throw new TypeError("Name contains invalid characters.");t.create=!!t.create;const i=await this[b].getDirectoryHandle(e,t);return new g(i)}async*entries(){const{FileSystemFileHandle:e}=await Promise.resolve().then((function(){return P}));for await(const[t,i]of this[b].entries())yield[i.name,"file"===i.kind?new e(i):new g(i)]}async*getEntries(){const{FileSystemFileHandle:e}=await Promise.resolve().then((function(){return P}));console.warn("deprecated, use .entries() instead");for await(let t of this[b].entries())yield"file"===t.kind?new e(t):new g(t)}async getFileHandle(e,t={}){const{FileSystemFileHandle:i}=await Promise.resolve().then((function(){return P}));if(""===e)throw new TypeError("Name can't be an empty string.");if("."===e||".."===e||e.includes("/"))throw new TypeError("Name contains invalid characters.");t.create=!!t.create;return new i(await this[b].getFileHandle(e,t))}async removeEntry(e,t={}){if(""===e)throw new TypeError("Name can't be an empty string.");if("."===e||".."===e||e.includes("/"))throw new TypeError("Name contains invalid characters.");return t.recursive=!!t.recursive,this[b].removeEntry(e,t)}async resolve(e){if(await e.isSameEntry(this))return[];const t=[{handle:this,path:[]}];for(;t.length;){let{handle:i,path:r}=t.pop();for await(const n of i.values()){if(await n.isSameEntry(e))return[...r,n.name];"directory"===n.kind&&t.push({handle:n,path:[...r,n.name]})}}return null}async*keys(){for await(const[e]of this[b].entries())yield e}async*values(){for await(const[e,t]of this)yield t}[Symbol.asyncIterator](){return this.entries()}}if(Object.defineProperty(g.prototype,Symbol.toStringTag,{value:"FileSystemDirectoryHandle",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(g.prototype,{getDirectoryHandle:{enumerable:!0},entries:{enumerable:!0},getFileHandle:{enumerable:!0},removeEntry:{enumerable:!0}}),globalThis.FileSystemDirectoryHandle){const e=globalThis.FileSystemDirectoryHandle.prototype;e.resolve=async function(e){if(await e.isSameEntry(this))return[];const t=[{handle:this,path:[]}];for(;t.length;){let{handle:i,path:r}=t.pop();for await(const n of i.values()){if(await n.isSameEntry(e))return[...r,n.name];"directory"===n.kind&&t.push({handle:n,path:[...r,n.name]})}}return null};const t=e.entries;e.entries=async function*(){await async function(e){const t=await navigator.storage.getDirectory();if(null===await t.resolve(e))throw new DOMException(...m)}(this),yield*t.call(this)},e[Symbol.asyncIterator]=async function*(){yield*this.entries()};const i=e.removeEntry;e.removeEntry=async function(e,r={}){return i.call(this,e,r).catch((async e=>{if(e instanceof DOMException&&"UnknownError"===e.name&&!r.recursive){if(!(await t.call(this).next()).done)throw new DOMException(...f)}throw e}))}}var F=Object.freeze({__proto__:null,default:g,FileSystemDirectoryHandle:g});const{INVALID:_,SYNTAX:S,GONE:E}=u,v=Symbol("adapter");class H extends w{[v];constructor(e){super(e),this[v]=e}async createWritable(e={}){return new d(await this[v].createWritable(e))}async getFile(){return this[v].getFile()}}if(Object.defineProperty(H.prototype,Symbol.toStringTag,{value:"FileSystemFileHandle",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(H.prototype,{createWritable:{enumerable:!0},getFile:{enumerable:!0}}),globalThis.FileSystemFileHandle&&!globalThis.FileSystemFileHandle.prototype.createWritable){const e=new WeakMap;let t;const i=()=>{let e,t;onmessage=async i=>{const r=i.ports[0],n=i.data;switch(n.type){case"open":const i=n.name;let r=await navigator.storage.getDirectory();for(const e of n.path)r=await r.getDirectoryHandle(e);e=await r.getFileHandle(i),t=await e.createSyncAccessHandle();break;case"write":t.write(n.data,{at:n.position}),t.flush();break;case"truncate":t.truncate(n.size);break;case"abort":case"close":t.close()}r.postMessage(0)}};globalThis.FileSystemFileHandle.prototype.createWritable=async function(r){if(!t){const e=`(${i.toString()})()`,r=new Blob([e],{type:"text/javascript"});t=URL.createObjectURL(r)}const n=new Worker(t,{type:"module"});let s=0;const a=new TextEncoder;let o=await this.getFile().then((e=>e.size));const l=e=>new Promise(((t,i)=>{const r=new MessageChannel;r.port1.onmessage=e=>{e.data instanceof Error?i(e.data):t(e.data),r.port1.close(),r.port2.close(),r.port1.onmessage=null},n.postMessage(e,[r.port2])})),c=await navigator.storage.getDirectory(),h=await e.get(this),w=await c.resolve(h);if(null===w)throw new DOMException(...E);await l({type:"open",path:w,name:this.name}),!1===r?.keepExistingData&&(await l({type:"truncate",size:0}),o=0);return new d({start:e=>{},async write(e){if("write"===(e=e?.constructor===Object?{...e}:{type:"write",data:e,position:s}).type){if(!("data"in e))throw await l({type:"close"}),new DOMException(...S("write requires a data argument"));if(e.position??=s,"string"==typeof e.data)e.data=a.encode(e.data);else if(e.data instanceof ArrayBuffer)e.data=new Uint8Array(e.data);else if(e.data instanceof Uint8Array||!ArrayBuffer.isView(e.data)){if(!(e.data instanceof Uint8Array)){const t=await new Response(e.data).arrayBuffer();e.data=new Uint8Array(t)}}else e.data=new Uint8Array(e.data.buffer,e.data.byteOffset,e.data.byteLength);Number.isInteger(e.position)&&e.position>=0&&(s=e.position),s+=e.data.byteLength,o+=e.data.byteLength}else{if("seek"===e.type){if(Number.isInteger(e.position)&&e.position>=0){if(o<e.position)throw new DOMException(..._);return console.log("seeking",e),void(s=e.position)}throw await l({type:"close"}),new DOMException(...S("seek requires a position argument"))}if("truncate"===e.type){if(!(Number.isInteger(e.size)&&e.size>=0))throw await l({type:"close"}),new DOMException(...S("truncate requires a size argument"));o=e.size,s>o&&(s=o)}}await l(e)},async close(){await l({type:"close"}),n.terminate()},async abort(e){await l({type:"abort",reason:e}),n.terminate()}})};const r=FileSystemDirectoryHandle.prototype.getFileHandle;FileSystemDirectoryHandle.prototype.getFileHandle=async function(...t){const i=await r.call(this,...t);return e.set(i,this),i}}var P=Object.freeze({__proto__:null,default:H,FileSystemFileHandle:H});const{WritableStream:T,TransformStream:D,DOMException:k,Blob:O}=l,{GONE:x}=u,z=/constructor/i.test(window.HTMLElement);class M{constructor(e){e.onmessage=e=>this._onMessage(e.data),this._port=e,this._resetReady()}start(e){return this._controller=e,this._readyPromise}write(e){const t={type:0,chunk:e};return this._port.postMessage(t,[e.buffer]),this._resetReady(),this._readyPromise}close(){this._port.postMessage({type:2}),this._port.close()}abort(e){this._port.postMessage({type:1,reason:e}),this._port.close()}_onMessage(e){0===e.type&&this._resolveReady(),1===e.type&&this._onError(e.reason)}_onError(e){this._controller.error(e),this._rejectReady(e),this._port.close()}_resetReady(){this._readyPromise=new Promise(((e,t)=>{this._readyResolve=e,this._readyReject=t})),this._readyPending=!0}_resolveReady(){this._readyResolve(),this._readyPending=!1}_rejectReady(e){this._readyPending||this._resetReady(),this._readyPromise.catch((()=>{})),this._readyReject(e),this._readyPending=!1}}class I{constructor(e){const t=new MessageChannel;this.readablePort=t.port1,this.writable=new e(new M(t.port2))}}var R=Object.freeze({__proto__:null,FileHandle:class{constructor(e="unkown"){this.name=e,this.kind="file"}async getFile(){throw new k(...x)}async isSameEntry(e){return this===e}async createWritable(e={}){const t=await(navigator.serviceWorker?.getRegistration()),i=document.createElement("a"),r=new D,n=r.writable;if(i.download=this.name,z||!t){let e=[];r.readable.pipeTo(new T({write(t){e.push(new O([t]))},close(){const t=new O(e,{type:"application/octet-stream; charset=utf-8"});e=[],i.href=URL.createObjectURL(t),i.click(),setTimeout((()=>URL.revokeObjectURL(i.href)),1e4)}}))}else{const{writable:i,readablePort:n}=new I(T),s=encodeURIComponent(this.name).replace(/['()]/g,escape).replace(/\*/g,"%2A"),a={"content-disposition":"attachment; filename*=UTF-8''"+s,"content-type":"application/octet-stream; charset=utf-8",...e.size?{"content-length":e.size}:{}},o=setTimeout((()=>t.active.postMessage(0)),1e4);r.readable.pipeThrough(new D({transform(e,t){if(e instanceof Uint8Array)return t.enqueue(e);const i=new Response(e).body.getReader(),r=e=>i.read().then((e=>e.done?0:r(t.enqueue(e.value))));return r()}})).pipeTo(i).finally((()=>{clearInterval(o)})),t.active.postMessage({url:t.scope+s,headers:a,readablePort:n},[n]);const l=document.createElement("iframe");l.hidden=!0,l.src=t.scope+s,document.body.appendChild(l)}return n.getWriter()}}});const{DISALLOWED:j}=u;class A{constructor(e,t){this.writer=e,this.fileEntry=t}async write(e){if("object"==typeof e)if("write"===e.type){if(Number.isInteger(e.position)&&e.position>=0&&(this.writer.seek(e.position),this.writer.position!==e.position&&(await new Promise(((t,i)=>{this.writer.onwriteend=t,this.writer.onerror=i,this.writer.truncate(e.position)})),this.writer.seek(e.position))),!("data"in e))throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. write requires a data argument","SyntaxError");e=e.data}else{if("seek"===e.type){if(Number.isInteger(e.position)&&e.position>=0){if(this.writer.seek(e.position),this.writer.position!==e.position)throw new DOMException("seeking position failed","InvalidStateError");return}throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. seek requires a position argument","SyntaxError")}if("truncate"===e.type)return new Promise((t=>{if(!(Number.isInteger(e.size)&&e.size>=0))throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. truncate requires a size argument","SyntaxError");this.writer.onwriteend=e=>t(),this.writer.truncate(e.size)}))}await new Promise(((t,i)=>{this.writer.onwriteend=t,this.writer.onerror=i,this.writer.write(new Blob([e]))}))}close(){return new Promise(this.fileEntry.file.bind(this.fileEntry))}}class N{constructor(e,t=!0){this.file=e,this.kind="file",this.writable=t,this.readable=!0}get name(){return this.file.name}isSameEntry(e){return this.file.toURL()===e.file.toURL()}getFile(){return new Promise(this.file.file.bind(this.file))}createWritable(e){if(!this.writable)throw new DOMException(...j);return new Promise(((t,i)=>this.file.createWriter((i=>{!1===e.keepExistingData?(i.onwriteend=e=>t(new A(i,this.file)),i.truncate(0)):t(new A(i,this.file))}),i)))}}class W{constructor(e,t=!0){this.dir=e,this.writable=t,this.readable=!0,this.kind="directory",this.name=e.name}isSameEntry(e){return this.dir.fullPath===e.dir.fullPath}async*entries(){const e=this.dir.createReader(),t=await new Promise(e.readEntries.bind(e));for(const e of t)yield[e.name,e.isFile?new N(e,this.writable):new W(e,this.writable)]}getDirectoryHandle(e,t){return new Promise(((i,r)=>{this.dir.getDirectory(e,t,(e=>{i(new W(e))}),r)}))}getFileHandle(e,t){return new Promise(((i,r)=>this.dir.getFile(e,t,(e=>i(new N(e))),r)))}async removeEntry(e,t){const i=await this.getDirectoryHandle(e,{create:!1}).catch((t=>"TypeMismatchError"===t.name?this.getFileHandle(e,{create:!1}):t));if(i instanceof Error)throw i;return new Promise(((e,r)=>{i instanceof W?t.recursive?i.dir.removeRecursively((()=>e()),r):i.dir.remove((()=>e()),r):i.file&&i.file.remove((()=>e()),r)}))}}var L=Object.freeze({__proto__:null,FileHandle:N,FolderHandle:W,default:(e={})=>new Promise(((t,i)=>window.webkitRequestFileSystem(e._persistent,0,(e=>t(new W(e.root))),i)))});const{File:U,Blob:q,DOMException:B}=l,{INVALID:C,GONE:G,MISMATCH:Y,MOD_ERR:V,SYNTAX:$,SECURITY:X,DISALLOWED:J}=u;class K{constructor(e,t){this.fileHandle=e,this.file=t,this.size=t.size,this.position=0}write(e){let t=this.file;if("object"==typeof e)if("write"===e.type){if(Number.isInteger(e.position)&&e.position>=0&&(this.position=e.position,this.size<e.position&&(this.file=new U([this.file,new ArrayBuffer(e.position-this.size)],this.file.name,this.file))),!("data"in e))throw new B(...$("write requires a data argument"));e=e.data}else{if("seek"===e.type){if(Number.isInteger(e.position)&&e.position>=0){if(this.size<e.position)throw new B(...C);return void(this.position=e.position)}throw new B(...$("seek requires a position argument"))}if("truncate"===e.type){if(Number.isInteger(e.size)&&e.size>=0)return t=e.size<this.size?new U([t.slice(0,e.size)],t.name,t):new U([t,new Uint8Array(e.size-this.size)],t.name),this.size=t.size,this.position>t.size&&(this.position=t.size),void(this.file=t);throw new B(...$("truncate requires a size argument"))}}e=new q([e]);let i=this.file;const r=i.slice(0,this.position),n=i.slice(this.position+e.size);let s=this.position-r.size;s<0&&(s=0),i=new U([r,new Uint8Array(s),e,n],i.name),this.size=i.size,this.position+=e.size,this.file=i}close(){if(this.fileHandle._deleted)throw new B(...G);this.fileHandle._file=this.file,this.file=this.position=this.size=null,this.fileHandle.onclose&&this.fileHandle.onclose(this.fileHandle)}}class Q{constructor(e="",t=new U([],e),i=!0){this._file=t,this.name=e,this.kind="file",this._deleted=!1,this.writable=i,this.readable=!0}async getFile(){if(this._deleted)throw new B(...G);return this._file}async createWritable(e){if(!this.writable)throw new B(...J);if(this._deleted)throw new B(...G);const t=e.keepExistingData?await this.getFile():new U([],this.name);return new K(this,t)}async isSameEntry(e){return this===e}async _destroy(){this._deleted=!0,this._file=null}}class Z{constructor(e,t=!0){this.name=e,this.kind="directory",this._deleted=!1,this._entries={},this.writable=t,this.readable=!0}async*entries(){if(this._deleted)throw new B(...G);yield*Object.entries(this._entries)}async isSameEntry(e){return this===e}async getDirectoryHandle(e,t){if(this._deleted)throw new B(...G);const i=this._entries[e];if(i){if(i instanceof Q)throw new B(...Y);return i}if(t.create)return this._entries[e]=new Z(e);throw new B(...G)}async getFileHandle(e,t){const i=this._entries[e],r=i instanceof Q;if(i&&r)return i;if(i&&!r)throw new B(...Y);if(!i&&!t.create)throw new B(...G);return!i&&t.create?this._entries[e]=new Q(e):void 0}async removeEntry(e,t){const i=this._entries[e];if(!i)throw new B(...G);await i._destroy(t.recursive),delete this._entries[e]}async _destroy(e){for(let t of Object.values(this._entries)){if(!e)throw new B(...V);await t._destroy(e)}this._entries={},this._deleted=!0}}const ee=new Z("");var te=Object.freeze({__proto__:null,Sink:K,FileHandle:Q,FolderHandle:Z,default:()=>ee});export{g as FileSystemDirectoryHandle,H as FileSystemFileHandle,w as FileSystemHandle,d as FileSystemWritableFileStream,o as getOriginPrivateDirectory,t as showDirectoryPicker,n as showOpenFilePicker,a as showSaveFilePicker};
