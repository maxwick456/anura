declare class LocalFSStats {
    name: string;
    size: number;
    atime: Date;
    mtime: Date;
    ctime: Date;
    atimeMs: number;
    mtimeMs: number;
    ctimeMs: number;
    node: string;
    nlinks: number;
    mode: number;
    type: "FILE" | "DIRECTORY";
    uid: number;
    gid: number;
    dev: string;
    isFile(): boolean;
    isDirectory(): boolean;
    isSymbolicLink(): boolean;
    constructor(data: Partial<LocalFSStats>);
}
declare class LocalFS extends AFSProvider<LocalFSStats> {
    dirHandle: FileSystemDirectoryHandle;
    domain: string;
    name: string;
    version: string;
    path: any;
    stats: Map<string, any>;
    fds: FileSystemHandle[];
    cursors: number[];
    constructor(dirHandle: FileSystemDirectoryHandle, domain: string);
    relativizePath(path: string): string;
    getChildDirHandle(path: string, recurseCounter?: number): Promise<[FileSystemDirectoryHandle, string]>;
    getFileHandle(path: string, options?: FileSystemGetFileOptions, recurseCounter?: number): Promise<[FileSystemFileHandle, string]>;
    static newOPFS(anuraPath: string): Promise<LocalFS>;
    static new(anuraPath: string): Promise<LocalFS>;
    readdir(path: string, _options?: any, callback?: (err: Error | null, files: string[]) => void): void;
    stat(path: string, callback?: (err: Error | null, stats: any) => void): void;
    readFile(path: string, callback?: (err: Error | null, data: typeof Filer.Buffer) => void): void;
    writeFile(path: string, data: Uint8Array | string, _options?: any, callback?: (err: Error | null) => void): void;
    appendFile(path: string, data: Uint8Array, callback?: (err: Error | null) => void): void;
    unlink(path: string, callback?: (err: Error | null) => void): void;
    mkdir(path: string, _mode?: any, callback?: (err: Error | null) => void): void;
    rmdir(path: string, callback?: (err: Error | null) => void): void;
    rename(srcPath: string, dstPath: string, callback?: (err: Error | null) => void): void;
    truncate(path: string, len: number, callback?: (err: Error | null) => void): void;
    /** @deprecated â€” fs.exists() is an anachronism and exists only for historical reasons. */
    exists(path: string, callback?: (exists: boolean) => void): void;
    promises: {
        saveStats: () => Promise<void>;
        writeFile: (path: string, data: Uint8Array | string, options?: any) => Promise<void>;
        readFile: (path: string) => Promise<any>;
        readdir: (path: string) => Promise<string[]>;
        appendFile: (path: string, data: Uint8Array) => Promise<void>;
        unlink: (path: string) => Promise<void>;
        mkdir: (path: string) => Promise<void>;
        rmdir: (path: string) => Promise<void>;
        rename: (oldPath: string, newPath: string) => Promise<void>;
        stat: (path: string) => Promise<LocalFSStats>;
        truncate: (path: string, len: number) => Promise<void>;
        access(path: string, mode: number): Promise<void>;
        chown(path: string, uid: number, gid: number): Promise<void>;
        chmod: (fullPath: string, mode: number) => Promise<void>;
        link: (existingPath: string, newPath: string) => Promise<void>;
        lstat: (path: string) => Promise<LocalFSStats>;
        mkdtemp: (template: string) => Promise<string>;
        open: (path: string, _flags: "r" | "r+" | "w" | "w+" | "a" | "a+", _mode?: any) => Promise<{
            fd: number;
            [AnuraFDSymbol]: string;
        }>;
        readlink: (path: string) => Promise<string>;
        symlink: (target: string, path: string) => Promise<void>;
        utimes: (path: string, atime: Date | number, mtime: Date | number) => Promise<void>;
    };
    ftruncate(fd: AnuraFD, len: number, callback?: (err: Error | null, fd: AnuraFD) => void): void;
    fstat(fd: AnuraFD, callback: (err: Error | null, stats: any) => void): void;
    lstat(path: string, callback?: (err: Error | null, stats: any) => void): void;
    link(existingPath: string, newPath: string, callback?: (err: Error | null) => void): void;
    symlink(target: string, path: string, type: any, callback?: (err: Error | null) => void): void;
    readlink(path: any, callback?: any): void;
    access(path: string, mode: any, callback?: (err: Error | null) => void): void;
    mkdtemp(prefix: string, options: any, callback?: (err: Error | null, path: string) => void): void;
    fchown(fd: AnuraFD, uid: number, gid: number, callback?: (err: Error | null) => void): void;
    chmod(path: string, mode: number, callback?: (err: Error | null) => void): void;
    fchmod(fd: AnuraFD, mode: number, callback?: (err: Error | null) => void): void;
    fsync(fd: AnuraFD, callback?: (err: Error | null) => void): void;
    write(fd: AnuraFD, buffer: Uint8Array, offset: number, length: number, position: number | null, callback?: (err: Error | null, nbytes: number) => void): void;
    read(fd: AnuraFD, buffer: Uint8Array, offset: number, length: number, position: number | null, callback?: (err: Error | null, bytesRead: number, buffer: Uint8Array) => void): void;
    utimes(path: string, atime: Date | number, mtime: Date | number, callback?: (err: Error | null) => void): void;
    futimes(fd: AnuraFD, atime: Date, mtime: Date, callback?: (err: Error | null) => void): void;
    chown(path: string, uid: number, gid: number, callback?: (err: Error | null) => void): void;
    close(fd: AnuraFD, callback: (err: Error | null) => void): void;
    open(path: string, flags: "r" | "r+" | "w" | "w+" | "a" | "a+", mode?: any, callback?: ((err: Error | null, fd: AnuraFD) => void) | undefined): void;
}
